@using MapColoringApp.Services
@using MudBlazor
@using System.Diagnostics
@using Microsoft.JSInterop
@inject IJSRuntime JS
@inject IColoringService ColoringService
@inject NavigationManager NavigationManager
@page "/"

<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; text-align: center;">

<MudGrid Justify="Justify.Center">

<MudItem>
<MudPaper Class="pa-4" Style="max-width: 900px; width: 100%;">
	<h1>Updates</h1>

	@*Domains table*@
	<DomainsTable Domains=domains/>

	@*Last MCVs*@


	@*Last Highest Degree*@



</MudPaper>
</MudItem>

<MudItem>
<MudPaper Class="pa-4" Style="max-width: 900px; width: 100%;">
<PageTitle>Interactive Map Coloring!!</PageTitle>

<h1>Interactive US Map</h1>


<object id="us-map" type="image/svg+xml" data="maps/us.svg" width="800" height="500"></object>


<MudCard Elevation="1" Class="pa-4 mt-4">
<MudText Color="Color.Error" Typo="Typo.h6" Class="mt-4">@status</MudText>
@if(!cspStarted) {

<MudButton @onclick="OpenColorPicker" Variant="Variant.Filled" Color="Color.Secondary">
Add New Color
</MudButton>
<MudSpacer/>
<MudButton @onclick="RunOnce" Variant="Variant.Filled" Color="Color.Primary">
Initialize CSP
</MudButton>
}
else {
<MudButton @onclick="Reset" Variant="Variant.Filled" Color="Color.Primary">
Reset
</MudButton>
<MudSpacer/>
<MudButton @onclick="RunOnce" Variant="Variant.Outlined" Color="Color.Primary">
Run CSP once
</MudButton>
}


<MudText>Number of Colors: @colors.Count</MudText>

<MudToggleGroup T="int" SelectionMode="SelectionMode.SingleSelection" Value="selectedColor" ValueChanged="@OnColorSelected">

@for(int i = 0; i < NumColors; i ++) {
	<MudToggleItem Value="i" Style="@GetButtonStyle(i)" Class="color-toggle-item" Text="">
		</MudToggleItem>
}

</MudToggleGroup>


<style>
.color-toggle-item.mud-toggle-item-selected {
border: 3px solid #000 !important;
	box-shadow: 0 0 10px rgba(0,0,0,0.5) !important;
transform: scale(1.05);
transition: all 0.2s ease;
}

.color-toggle-item:hover {
transform: scale(1.02);
transition: all 0.2s ease;
}

.color-toggle-item {
margin: 4px !important;
	border-radius: 8px !important;
}
</style>
</MudCard>

</MudPaper>
</MudItem>
</MudGrid>

</div>

@if (colorPickerOpen) {
	<MudCard Color="Color.Primary" Style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 9999; width: 90%; max-width: 400px; max-height: 90vh; overflow-y: auto;">
		<MudCardHeader>
		<CardHeaderContent>
		<MudText>Pick a color to add!</MudText>	
		</CardHeaderContent>
		</MudCardHeader>		
		<MudCardContent>
		<MudColorPicker Label="Color picker" ShowAlpha="false" ShowInputs="false" @bind-Text="pickedColor" PickerVariant="PickerVariant.Static" ColorPickerView="ColorPickerView.Grid" Style="@($"color: {pickedColor};")" Placeholder="Select color" />
		</MudCardContent>
		<MudCardActions>
		<MudButton OnClick="CancelColorPicker">Cancel</MudButton>
		<MudButton Color="Color.Primary" OnClick="SaveColorPicker">Save</MudButton>
		</MudCardActions>
		</MudCard>
}


@code {
	string status = "";

	private Action<object, string> errorHandler;
	//color picker
	private bool colorPickerOpen = false;
	
	private string pickedColor = "#ff0000";

	//store to send to backend and js
	private int selectedColor;
	private int NumColors => colors.Count;
	private List<string> colors = new();

	//to store in ColoringRequest
	private List<string> initialStateIds = new();
	private List<int> initialColorsIndexes = new();

	//updates
	private Dictionary<string, List<string>> domains = new();

	bool cspStarted = false;

	//	private Dictionary<string, int?> StateAssignments = new();

	[JSInvokable]
		public async Task OnStateClicked(string stateId) {
			//add to respective lists of states and color for each state at index i
			initialStateIds.Add(stateId);
			initialColorsIndexes.Add(selectedColor);


			//set color to state in js
			if(!cspStarted) {
				status = stateId;
				await ColorState(stateId, colors[selectedColor]);
				StateHasChanged();
			}
		}

	public async Task ColorState(string stateId, string color) {
		await JS.InvokeVoidAsync("colorState", stateId, color);
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
		//	StartStateClickMonitoring();
		}
	}

	private void HandleError(object sender, string errorMessage)
	{
		status = $"Error: {errorMessage}";
		InvokeAsync(StateHasChanged);
	}

	protected override async void OnInitialized()
	{
		errorHandler += HandleError;
	await JS.InvokeVoidAsync("setDotNetReference", DotNetObjectReference.Create(this));
		selectedColor = 0;
		domains = new Dictionary<string, List<string>>();
		// Initialization logic here
	}

	//color picker functions
	private Task OpenColorPicker() {
		colorPickerOpen = true;
		StateHasChanged();
		return Task.CompletedTask;
	}

	private Task CancelColorPicker() {
		colorPickerOpen = false;
		return Task.CompletedTask;
	}

	private Task SaveColorPicker() {
		if(colors.Contains(pickedColor)) {
			errorHandler?.Invoke(this, "color already exists, pick another");
			StateHasChanged();
			return Task.CompletedTask;
		}
		colorPickerOpen = false;
		colors.Add(pickedColor);
		selectedColor = colors.Count - 1;
		return Task.CompletedTask;
	}

	private async Task Reset() {
		NavigationManager.NavigateTo(NavigationManager.Uri, forceLoad: true);
	}

	private async Task RunOnce() {
		if(!cspStarted) {
			if(colors.Count == 0 || colors == null) {
				errorHandler?.Invoke(this, "Add at least one color to start CSP");
				InvokeAsync(StateHasChanged);
				return;
			}
			var requestToSend = new ColoringRequest
			{
				StateIds = initialStateIds,
				SelectedColors = initialColorsIndexes,
				Colors = colors
			};

			await ColoringService.StartAsync(requestToSend);

			cspStarted = true;
		}
		else {
			var res = await ColoringService.RunOnceAsync();
			await ColorState(res.StateId, res.Color);
			domains = res.Domains;
			//Console.WriteLine(res.Domains);

			InvokeAsync(StateHasChanged);
		}

	}

	/*private async void StartStateClickMonitoring()
	{
		while (true)
		{
			try
			{
				var clickedState = await JS.InvokeAsync<string>("getLastClickedState");
				if (!string.IsNullOrEmpty(clickedState))
				{
					Console.WriteLine($"State clicked: {clickedState}");
					await OnStateClicked(clickedState);
				}
				await Task.Delay(100); // Check every 100ms
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Error monitoring state clicks: {ex.Message}");
				break;
			}
		}
	}
	*/

	private string GetButtonStyle(int index)
	{
		return $"background-color:{colors[index]} !important; width:200px; height:50px; border: 3px solid transparent; --mud-palette-action-default: {colors[index]} !important; --mud-palette-action-default-hover: {colors[index]} !important;";
	}    


	private void OnColorSelected(int color)
	{
		selectedColor = color;
		string colorToSend = colors[color];
		StateHasChanged(); // Force the component to re-render
		JS.InvokeVoidAsync("setSelectedColor", colorToSend); // Update JavaScript
	}
}
